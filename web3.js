// Here is how the web3.js ETH library will interact with our smart contract
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
vae contractAddress = /* our contract address on ETH after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// 'ZombieFactory' has access to our contracts Public functions and events

// some sort of event listener to take the text input:
$("#ourButton").click(function(e) {
    var name = $("#nameInput").val()
    // Call our contract's 'createRandomZombie' function:
    ZombieFactory.createRandomZombie(name)
})

// Listen for the `NewZombie` event, and update the UI
var event = ZombieFactory.NewZombie(function(error, result) {
    if (error) return
    generateZombie(result.zombieId, result.name, result.dna)
})

// Take the Zombie dna, and update our image 
function generateZombie(id, name, dna) {
    let dnaStr = String(dna)
    // pad DNA with leading zeroes if it's less than 16 chars
    while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

    let zombieDetails = {
        // First 2 digits make up the head. We have 7 possible heads, so & 7
        // to get and int from 0 - 6, then add 1 to make it 1 - 7. Then we have 7
        // image files named "head1.png" through "head7.png" we load based on 
        // this number:
        headChoice: dnaStr.substring(0,2) % 7 + 1,
        // 2nd 2 digits make up the eyes of 11 variations
        eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
        // 6 variations of shirts:
        shirtChoice: dnaStr.substring(4,6) & 6 + 1,
        // last 6 control color. Updated using CSS filter: hue-rotate
        //which has 360:
        skinColorChoice: parseInt(dnaStr.substring(6,8) / 100 * 300),
        eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 300),
        clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 300),
        zombeName: name,
        zombieDescription: "A Level 1 CryptoZombie",
    }
    return zombieDetails
}

// Our JS then does is take the values generated in the zombieDetails above, and use some 
// browser based js magic (we're using Vue.js) to swap out the images and aply CSS 
// filters. You'll get all the code for this in a later lesson.


// Event - Click a button
// Event Handler - onClick
// Action - Open Menu
// HTML Event handling
<button id="js-btn"
onClick="clickHandler()"> Click Me! </button>
//1 Plug into HTML element on which to listen for an event
//2 Use addEventListener method on the doc object

const jsBtn = document.getElementById('js-btn') // Declare constant and assign value from DOM
jsBtn.addEventListener('click', function() {
    console.log('clicked')
});


// anon ES5 functions
<button onClick={function() {console.log('first example')}}>
    An inline anonymous ES5 function event handler
</button>

// handling w/ arrow functions
<button onClick={() => console.log('second example')}>
    An inline anon ES6 functionevent handler
</button>

// Handling events using separate function declarations
function App() {
    function thirdExample() {
        console.log('third example');
    };
    return {
        <div className="thirdExample">
            <button onClick={thirdExample}>
                using a separate function declaration
            </button>
        </div>
    };
};
export default App;


// Handling events w/ separate functions

function App() {
    const fourthExample = () => console.log('fourth example');

    return (
        <div className="fourthExample">
            <button onClick={fourthExample}>
                using a separate functional expression
            </button>
        </div>
    );
};